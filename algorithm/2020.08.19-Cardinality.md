
<!-- tags: complexity -->
<!-- created: 2020-08-19 23:46 -->

# 基数计数

> 所谓的基数计数就是统计一组元素中不重复的元素的个数。如统计某个网站的UV，或者用户搜索网站的关键词数量；再如对一个网站分别统计了三天的UV，现在需要知道这三天的UV总量是多少，怎么融合多个统计值。


<!-- more -->

### 计数方法

1. 集合处理去重

    > 时间复杂为O(m2)，空间复杂度随元素个数线性增长。数据量一大就崩了。

2. B+Tree

    > 将数据插入到B+树中达到去重目的，然后顺序访问叶节点链从而得到n值。时间复杂的为O(lgm+n)，内存亦随元素个数线性增长。数据量一大就崩了。

3. Bitmap

    > 用位数组来表示各元素是否出现，每个元素对应一位，所需的总内存为n bit。能大大减少内存占用且位操作迅速。
    > 如果要统计1亿个数据的基数值，大约需要内存100000000/8/1024/1024 ≈ 12M，内存减少占用的效果显著。然而统计一个对象的基数值需要12M，如果统计10000个对象，就需要将近120G，同样不能广泛用于大数据场景。

4. 概率算法

    > 实际上目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。概率算法不直接存储数据集合本身，通过一定的概率统计方法预估基数值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。

    目前用于基数计数的概率算法包括:

    - Linear Counting(LC)：

        早期的基数估计算法，LC在空间复杂度方面并不算优秀，实际上LC的空间复杂度与上文中简单bitmap方法是一样的（但是有个常数项级别的降低），都是O(Nmax)；

    - LogLog Counting(LLC)：

        相比于LC更加节省内存，空间复杂度只有O(log2(log2(N​max)))；

    - HyperLogLog Counting(HLL)：

        基于LLC的优化和改进，在同样空间复杂度情况下，能够比LLC的基数估计误差更小。
